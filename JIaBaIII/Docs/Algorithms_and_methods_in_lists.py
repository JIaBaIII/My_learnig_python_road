from JIaBaIII.Docs.list_2D_practice import print_list_2d

# ********************************************************************************************************************
#                                     >>>>> Находит наибольшее число x <<<<<
# ********************************************************************************************************************

# x = 4327612
# m = 0
# while x > 0:
#     if (x % 10) > m:
#         m = (x % 10)
#     x //= 10
#     print(x, m)
# print(m)


# ********************************************************************************************************************
#                                   >>>>> Алгоритм для подсчета суммы чисел <<<<<
# ********************************************************************************************************************
#         Посчитать сумму чисел от 1 до 10000

# max_num = 10000
# summ = max_num * (max_num + 1) // 2  # ОЧЕНЬ ВАЖНАЯ ФОРМУЛА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# print(summ)

# ********************************************************************************************************************
#                                          >>> Алгоритмы в списках <<<
# ********************************************************************************************************************

#                                         ---- Подсчет количества ----

# 1 Требуется подсчитать, сколько работников завода получают з\п менее 20000 рублей в месяц.

# workers_zp = [22000, 15000, 19500, 24000, 20000, 12365, 23000]
#
# count = 0
# for i in workers_zp:
#     if i < 20000:
#         count += 1
#
# print(f'Работников, получаящих меньше 20000 рублей в месяц = {count} чел.')

# --------------------------------------------------------------------------------------------------------------------

#                                            ---- Номер элемента ----

# 2 Автоматизированная система учёта парковочных мест работает со списком, в котором индексами являются номера парковок
# (от 0 до 9 включительно), а содержимым - трёхзначный номер припаркованного на этом месте автомобиля.
# Номера хранятся в виде строк. Определить, на каком месте стоит автомобиль с номером X или сообщить, что на парковке
# его нет.

# number = '311'
# parking = ['-', '-', '132', '155', '-', '521', '311', '-', '555', '839']
#
# park = None
# p1 = 0
#
#
# while park is None and p1 < len(parking):
#     if parking[p1] == number:
#         park = p1
#     p1 += 1
#
# if park is not None:
#     print(f'Автомобиль стоит на {park} месте')
# else:
#     print('Автомобиля на стоянке нет')

# --------------------------------------------------------------------------------------------------------------------

#                                          ---- Сортировка пузырьком ----

# 3 Счетчик количества просмотров страниц сайта реализован в виде списка, в котором каждый элемент содержит кол-во
# просмотров той или иной страницы. Например, по индексу 0 хранятся просмотры главной страницы, по индексу 1 -
# первой ссыли, 2 - второй и т.д.
# Требуется написать программу, которая позволит оценить посещаемость страниц.
# Программа должна вывести на экран количество просмотров страниц сайта в порядке убывания, номера страниц выводить
# не нужно.

# # Список с кол-вом просмотра страниц
# sites = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
# for i in range(len(sites) - 1):
#     for j in range(len(sites) - 1 - i):  # ( - 1 - i ) --- специально, что б не пересчитывался элемент,
#         #                                                                          который уже стоит на нужном месте
#         if sites[j] < sites[j + 1]:
#             sites[j], sites[j + 1] = sites[j + 1], sites[j]
#
# print(sites)

#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----

#                                          ---- Сортировка вставками ----

# # Список с кол-вом просмотра страниц
# sites = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
# # Обязательно начинаем с 1 элемента в in range()!!!!
# for i in range(1, len(sites)):
#     n = sites[i]  # Запоминаем тукущий элемент
#     j = i - 1  # Теперь формируем индекс для вставки
#     while j >= 0 and sites[j] < n:  # Пока индекс j больше нуля и элемент от индекса j меньше запомненного числа
#         sites[j + 1] = sites[j]  # Сдвигаем, освобождая место для запомненного в n элемента
#         j -= 1  # Уменьшаем индекс j
#     sites[j + 1] = n  # Устанавливаем сохраненное значение n в найденое место
#
# print(sites)

# --------------------------------------------------------------------------------------------------------------------

#                                           ---- Сортировка символов ----

# Отсортировать строку символов, расположив их в алфавитном порядке

# def string_sort(s):
#     ret = ''
#
#     code = []  # Список для кодов
#
#     for i in s:  # Формируем список кодов
#         code.append(ord(i))
#
#     for i in range(1, len(code)):  # Сортировка вставками
#         n = code[i]
#         j = i - 1
#         while j >= 0 and code[j] > n:
#             code[j + 1] = code[j]
#             j -= 1
#         code[j + 1] = n
#
#     for i in code:  # Формируем строку по кодам
#         ret += chr(i)
#
#     return ret
#
#
# stinga = 'ИАИОДФСПНУКЙЗЩРОЛМЧЯТЛДФМЯТМЧЯБИМЯЧЬБИЧРАУРГПОЫЛВМСЧБИ'
# stinga = string_sort(stinga)
# print(stinga)

# --------------------------------------------------------------------------------------------------------------------

#                                          ---- Встроенная сортировка ----

#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----

#                                         Методом .sort / .sort(reverse=True)

# Пример:
# some_list = [3, 2, 1, 5, 4]
#
# some_list.sort()
# print(f'Сортировка списка в порядке возростания: {some_list}')  # [1, 2, 3, 4, 5]
#
# some_list.sort(reverse=True)
# print(f'Сортировка списка в обратном порядке: {some_list}')  # [5, 4, 3, 2, 1]


#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----

#                                                 Методом sorted()

# some_list_1 = [3, 2, 1, 5, 4]
#
# # Удобно использовать в цикле:
# for i in sorted(some_list_1):
#     print(i, '', end='')        # 1 2 3 4 5
#
# print()
#
# # Так же можно применить и в обратном порядке
# for i in sorted(some_list_1, reverse=True):
#     print(i, '', end='')        # 5 4 3 2 1
#
# print('\n')
#
# # Метод sorted() позволяет сохранить исходный список неизменным, сортирую его через for
# print(f'Исходный список: {some_list_1}')
# print(f'Вывод отсортированного списка: {sorted(some_list_1)}')
# print(f'Исходный список не изменился: {some_list_1}')
#
# print()
#
#
# # Можно отсортировать слова по алфавиту, но в тот же список
# b = ['Молоко', 'Эчпочмак', 'Чай', 'Кофе', 'Ваниль', 'Кефир']
# print(b)
# b = sorted(b)
# print(b)
#
# # При помощи reverse=True, можно отсортировать в в обратом алфавите

# --------------------------------------------------------------------------------------------------------------------

#                                     ---- Сортировка двумерного списка ----

# Задача: предположим, у нас есть игровое поле 4х4 с расположенными на нём "пазлами". Каждый пазл имеет уникальный
# номер от 1 до 16 включительно. Общая картинка собирается правильно только в том случае, когда все пазлы
# расположены в возрастающей последовательности.
# Написать программу, формирующую поле с пазлами, стоящими в "правильных" местах.
# Правильный порядок puzzles_example должен быть = [[1, 2, 3, 4],
#                                         [5, 6, 7, 8],
#                                         [9, 10, 11, 12],
#                                         [13, 14, 15, 16]]

# puzzles_example = [[16, 6, 11, 7],
#                    [5, 12, 13, 14],
#                    [3, 9, 15, 10],
#                    [1, 4, 8, 2]]


# Вариант # 1
# Из двумерного списка сделать одномерный, отсортировать и собрать снова двумерный список


#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----

# Вариант # 2
# Создать список с индексами элементов сортируемого двумерного списка и брать индексы оттуда,
# не работая с ними напрямую при помощи счётчиков циклов.

# # Функция, возвращаяющая двумерный списокиндексов двумерного списка
# def get_index_array(my_list):
#     ret = []
#     for i in range(len(my_list)):
#         for j in range(len(my_list[i])):
#             ret.append([])
#             ret[(i * len(my_list)) + j].append(i)
#             ret[(i * len(my_list)) + j].append(j)
#     return ret
#
#
# puzzles = [[16, 6, 11, 7],
#            [5, 12, 13, 14],
#            [3, 9, 15, 10],
#            [1, 4, 8, 2]]
#
# # Получаем индексы x и y
# idx = get_index_array(puzzles)
# # for i in idx:
# #     print(i)
# # # Индексы [0, 0][0, 1][0, 2][0, 3][1, 0][1, 1][1, 2][1, 3][2, 0][2, 1][2, 2][2, 3][3, 0][3, 1][3, 2][3, 3]
#
#
# # Теперь в нашем списке получится список индексов, где, например, по 'адресу' [0][0] будет храниться номер строки,
# # а [0][1] - номер столбца двумерного списка.   За счёт того, что самый первый индекс нашего нового списка всегда
# # указывает на номер ячейки двумерного списка для сортировки, всё можно сделать очень """просто?"""
#
#
# # Функциия, возвращающая отсортированный двумерный список. В параметры функции передаются my_list - список,
# # который нужно отсортировать и index - список индексов списка my_list. Возвращается двумерный отсортированный список.
# def get_sorted_array(my_list, index):
#     for i in range(len(index) - 1):
#         for j in range(len(index) - 1 - i):
#             if my_list[index[j][0]][index[j][1]] > my_list[index[j + 1][0]][index[j + 1][1]]:
#                 my_list[index[j][0]][index[j][1]], my_list[index[j + 1][0]][index[j + 1][1]] = \
#                     my_list[index[j + 1][0]][index[j + 1][1]], my_list[index[j][0]][index[j][1]]
#     return my_list
# # Используется обычная пузырьковая сортировка, в которой каждый элемент по индексам списка index сравнивается со
# # следующим по индексам списка index и, в случае если первый больше второго, они меняются.
#
#
# print(print_list_2d(get_sorted_array(puzzles, idx)))

#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----

# Вариант # 3
# Самый, как по мне, трудоемкий... Организовать перебор списка путём изменения индексов по строке и столбцам,
# сравнивать, к примеру, элемент на позиции [0][0] и позиции [0][1], [0][3] и [1][0].


#   -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----  -----
